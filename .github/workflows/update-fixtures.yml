name: Update fixtures (ESPN)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "23 5 * * *"   # daily 05:23 UTC

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Build assets from ESPN
        run: |
          python - <<'PY'
          import json, os, urllib.request, datetime, sys, ssl
          ssl._create_default_https_context = ssl._create_unverified_context

          # --- ESPN constants ---
          # PL comp: eng.1
          # Man United team id on ESPN: 360
          ESPN_SCHEDULE = "https://site.api.espn.com/apis/v2/sports/soccer/eng.1/teams/360/schedule"
          ESPN_TABLE    = "https://site.api.espn.com/apis/v2/sports/soccer/eng.1/standings"

          UA = {"User-Agent":"Mozilla/5.0"}

          def fetch(url):
            req = urllib.request.Request(url, headers=UA)
            with urllib.request.urlopen(req, timeout=60) as r:
              return json.loads(r.read().decode("utf-8"))

          def to_date_time(iso):
            # ESPN dates are ISO strings; we only need local date+time-ish
            try:
              # iso like "2025-09-27T11:30Z"
              d = datetime.datetime.fromisoformat(iso.replace("Z","+00:00"))
              date = d.date().isoformat()
              time = d.strftime("%H:%M")
              return date, time
            except Exception:
              return "", "TBC"

          # ---------- Fixtures (past + future) ----------
          data = fetch(ESPN_SCHEDULE)
          events = (data.get("events") or []) + (data.get("nextEvents") or [])

          fixtures = []
          for ev in events:
            date, time = to_date_time(ev.get("date",""))
            comp = ((ev.get("competitions") or [{}])[0].get("name")) or (ev.get("league","") or "")
            comp = comp or ((ev.get("competitions") or [{}])[0].get("venue",{}).get("fullName","") and "English Premier League") or "English Premier League"

            # teams
            comps = (ev.get("competitions") or [{}])[0]
            teams = comps.get("competitors") or []
            home, away = None, None
            for t in teams:
              if t.get("homeAway") == "home":
                home = t
              else:
                away = t
            if not home or not away:
              continue

            home_team = (home.get("team") or {})
            away_team = (away.get("team") or {})
            hname = home_team.get("displayName") or home_team.get("name") or ""
            aname = away_team.get("displayName") or away_team.get("name") or ""
            hbadge = (home_team.get("logo") or home_team.get("logos",[{}])[0].get("href"))
            abadge = (away_team.get("logo") or away_team.get("logos",[{}])[0].get("href"))

            status = (ev.get("status") or {}).get("type",{}).get("name","")
            # ESPN types: STATUS_SCHEDULED, STATUS_IN_PROGRESS, STATUS_FINAL
            if status == "STATUS_FINAL":
              hs = int(home.get("score") or 0)
              as_ = int(away.get("score") or 0)
              score = f"{hs}–{as_}"
              st = "FT"
            elif status == "STATUS_SCHEDULED":
              score = None
              st = "UPCOMING"
            else:
              # live / postponed etc.
              score = None
              st = "upcoming"

            fixtures.append({
              "date": date,
              "time": time or "TBC",
              "comp": comp,
              "home": hname,
              "away": aname,
              "status": st,
              "score": score,
              "venue": ((comps.get("venue") or {}).get("fullName") or ""),
              "tv": [],
              "homeBadge": hbadge,
              "awayBadge": abadge,
            })

          # dedup + sort
          seen = set()
          clean = []
          for f in fixtures:
            k = (f["date"], f["home"], f["away"])
            if f["date"] and k not in seen:
              seen.add(k); clean.append(f)
          clean.sort(key=lambda x: (x["date"], x["time"], x["home"], x["away"]))

          os.makedirs("assets", exist_ok=True)
          with open("assets/fixtures.json","w",encoding="utf-8") as out:
            json.dump(clean, out, ensure_ascii=False, indent=2)
          print("fixtures written:", len(clean))

          # ---------- Standings (full table) ----------
          tdata = fetch(ESPN_TABLE)
          rows = []
          # ESPN returns groups/children; drill down to "children" → "standings" → "entries"
          # There can be multiple groups, but PL is single-table; take the first group with entries.
          groups = (tdata.get("children") or tdata.get("standings") or [])
          # normalize into a list of entries
          entries = None
          for g in groups:
            # sometimes under g["standings"]["entries"]
            st = g.get("standings") or {}
            ent = st.get("entries")
            if ent:
              entries = ent
              break
          if entries is None:
            # fallback: sometimes it's directly in tdata["standings"]["entries"]
            entries = ((tdata.get("standings") or {}).get("entries") or [])

          def metric(obj, name, default=0):
            try:
              for m in (obj.get("stats") or []):
                if m.get("name") == name:
                  return int(m.get("value") or 0)
              return default
            except Exception:
              return default

          rank = 1
          table = []
          for e in entries:
            team = e.get("team") or {}
            name = team.get("displayName") or team.get("name") or ""
            crest = (team.get("logo") or team.get("logos",[{}])[0].get("href"))
            stats = e.get("stats") or []

            def get(name):
              for s in stats:
                if s.get("name")==name:
                  return int(s.get("value") or 0)
              return 0

            played = get("gamesPlayed")
            win    = get("wins")
            draw   = get("ties")
            loss   = get("losses")
            gf     = get("pointsFor") or get("goalsFor")
            ga     = get("pointsAgainst") or get("goalsAgainst")
            gd     = gf - ga
            points = get("points")

            table.append({
              "rank": rank,
              "team": name,
              "played": played,
              "win": win,
              "draw": draw,
              "loss": loss,
              "gf": gf,
              "ga": ga,
              "gd": gd,
              "points": points,
              "badge": crest,
            })
            rank += 1

          with open("assets/table.json","w",encoding="utf-8") as out:
            json.dump(table, out, ensure_ascii=False, indent=2)
          print("table written:", len(table))

          # bump a stamp so Pages rebuilds
          from datetime import timezone
          with open("assets/update_stamp.txt","w",encoding="utf-8") as f:
            f.write(datetime.datetime.now(timezone.utc).isoformat())
          PY

      - name: Commit & push (always)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add assets/*
          if git diff --cached --quiet; then
            git commit --allow-empty -m "chore: force pages rebuild (ESPN) [skip ci]"
          else
            git commit -m "chore: update fixtures & table from ESPN [skip ci]"
          fi
          git push
