name: Update site data (TSDB season → table + MUFC fixtures)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "23 5 * * *"   # daily 05:23 UTC

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Build assets
        env:
          SEASON: ${{ vars.SEASON }}
        run: |
          python - <<'PY'
          import json, os, pathlib, time, urllib.request, datetime, sys

          LEAGUE_ID = "4328"  # Premier League

          def get(url, tries=4, sleep=1.2):
            for i in range(tries):
              try:
                req = urllib.request.Request(url, headers={"User-Agent":"thekeelan-updater/2.5"})
                with urllib.request.urlopen(req, timeout=35) as r:
                  return json.loads(r.read().decode("utf-8"))
              except Exception as e:
                if i == tries-1:
                  print(f"[ERR] GET {url} -> {e}", file=sys.stderr)
                  raise
                time.sleep(sleep)

          def to_int(x):
            try: return int(x)
            except: return None

          def norm_ts(strTimestamp, dateEvent, strTime):
            ts = (strTimestamp or "").strip()
            if not ts:
              d = (dateEvent or "").strip()
              t = (strTime or "00:00:00").strip()
              ts = f"{d}T{t}".strip() if d else t
            if ts and 'Z' not in ts and '+' not in ts:
              ts += 'Z'
            return ts

          # season autodetect (Aug→Jul), allow override
          forced = (os.environ.get("SEASON") or "").strip()
          if forced:
            SEASON = forced
          else:
            today = datetime.date.today()
            SEASON = f"{today.year}-{today.year+1}" if today.month >= 8 else f"{today.year-1}-{today.year}"
          print(f"[INFO] Season: {SEASON}")

          season_events = get(f"https://www.thesportsdb.com/api/v1/json/3/eventsseason.php?id={LEAGUE_ID}&s={SEASON}") or {}
          events = season_events.get("events") or []

          # derive participants from events, top-up with table & league list
          event_teams = []
          for e in events:
            for k in ("strHomeTeam","strAwayTeam"):
              nm = (e.get(k) or "").strip()
              if nm: event_teams.append(nm)

          table_rows = (get(f"https://www.thesportsdb.com/api/v1/json/3/lookuptable.php?l={LEAGUE_ID}&s={SEASON}") or {}).get("table") or []
          table_teams = [(r.get("strTeam") or "").strip() for r in table_rows if (r.get("strTeam") or "").strip()]

          search_rows = (get("https://www.thesportsdb.com/api/v1/json/3/search_all_teams.php?l=English%20Premier%20League") or {}).get("teams") or []
          league_teams = [(t.get("strTeam") or "").strip() for t in search_rows if (t.get("strTeam") or "").strip()]

          participants, seen = [], set()
          def add_many(lst):
            for nm in lst:
              if nm and nm not in seen:
                participants.append(nm); seen.add(nm)
                if len(participants) >= 20: return
          add_many(sorted(set(event_teams)))
          if len(participants) < 20: add_many(table_teams)
          if len(participants) < 20: add_many(league_teams)
          participants = participants[:20]

          # badges for full league, then subset for participants
          try:
            all_teams = get(f"https://www.thesportsdb.com/api/v1/json/3/lookup_all_teams.php?id={LEAGUE_ID}") or {}
            league_badges = { (t.get("strTeam") or "").strip(): t.get("strTeamBadge") or None
                              for t in (all_teams.get("teams") or []) }
          except Exception:
            league_badges = {}
          badges_subset = {nm: league_badges.get(nm) for nm in participants}

          # build standings from finished matches
          standings_map = {
            nm: {"team": nm, "played":0,"won":0,"drawn":0,"lost":0,"gf":0,"ga":0,"gd":0,"pts":0,"badge": badges_subset.get(nm)}
            for nm in participants
          }
          for e in events:
            home = (e.get("strHomeTeam") or "").strip()
            away = (e.get("strAwayTeam") or "").strip()
            if home not in standings_map or away not in standings_map:
              continue
            hs = to_int(e.get("intHomeScore")); as_ = to_int(e.get("intAwayScore"))
            if hs is None or as_ is None:  # finished only
              continue
            H = standings_map[home]; A = standings_map[away]
            H["played"] += 1; A["played"] += 1
            H["gf"] += hs; H["ga"] += as_; H["gd"] = H["gf"] - H["ga"]
            A["gf"] += as_; A["ga"] += hs; A["gd"] = A["gf"] - A["ga"]
            if hs == as_:
              H["drawn"] += 1; A["drawn"] += 1; H["pts"] += 1; A["pts"] += 1
            elif hs > as_:
              H["won"] += 1; A["lost"] += 1; H["pts"] += 3
            else:
              A["won"] += 1; H["lost"] += 1; A["pts"] += 3

          rows = list(standings_map.values())
          rows.sort(key=lambda r: (-r["pts"], -r["gd"], -r["gf"], r["team"]))
          for i, r in enumerate(rows, start=1):
            r["pos"] = i

          new_table = {"season": SEASON, "updated": datetime.datetime.utcnow().isoformat()+"Z", "standings": rows}
          badges_json = {"season": SEASON, "updated": new_table["updated"], "badges": {nm: badges_subset.get(nm) for nm in participants}}

          # MUFC fixtures (season + last + next)
          mu_names = {"manchester united","man utd","manchester u."}
          search = get("https://www.thesportsdb.com/api/v1/json/3/searchteams.php?t=Manchester%20United") or {}
          mu = None
          for tr in (search.get("teams") or []):
            if (tr.get("strTeam") or "").strip().lower() in mu_names:
              mu = tr; break
          mu = mu or (search.get("teams") or [None])[0]
          if not mu: 
            print("[ERR] No MUFC team found", file=sys.stderr); sys.exit(1)
          mu_id = mu["idTeam"]

          last = get(f"https://www.thesportsdb.com/api/v1/json/3/eventslast.php?id={mu_id}") or {}
          nxt  = get(f"https://www.thesportsdb.com/api/v1/json/3/eventsnext.php?id={mu_id}") or {}

          def map_event(e):
            def norm(x): return (x or "").strip()
            ts = (e.get("strTimestamp") or "").strip()
            if not ts:
              d = norm(e.get("dateEvent")); t = norm(e.get("strTime") or "00:00:00")
              ts = f"{d}T{t}"
            if 'Z' not in ts and '+' not in ts: ts += 'Z'
            hs, as_ = to_int(e.get("intHomeScore")), to_int(e.get("intAwayScore"))
            finished = (hs is not None and as_ is not None)
            status = "FINISHED" if finished else "SCHEDULED"
            score = None
            if finished:
              home, away = norm(e.get("strHomeTeam")), norm(e.get("strAwayTeam"))
              is_mu_home = (home.lower() in mu_names)
              mu_sc, op_sc = (hs, as_) if is_mu_home else (as_, hs)
              outcome = "D" if mu_sc == op_sc else ("W" if mu_sc > op_sc else "L")
              score = {"home": hs, "away": as_, "outcome": outcome}
            return {
              "date": ts,
              "comp": e.get("strLeague") or (e.get("strLeagueShort") or ""),
              "home": e.get("strHomeTeam") or "",
              "away": e.get("strAwayTeam") or "",
              "status": status,
              "score": score,
              "tv": (e.get("strTVStation") or "").strip() or None
            }

          raw = []
          raw.extend(events)
          raw.extend(last.get("results") or [])
          raw.extend(nxt.get("events") or [])
          mu_names_l = {x.lower() for x in mu_names}
          mapped = [map_event(e) for e in raw
                    if (e.get("strHomeTeam") or "").strip().lower() in mu_names_l
                    or (e.get("strAwayTeam") or "").strip().lower() in mu_names_l]

          dedup, seen = [], set()
          for m in mapped:
            k = (m["date"], m["home"], m["away"])
            if k not in seen:
              seen.add(k); dedup.append(m)
          dedup.sort(key=lambda m: m["date"])

          new_fixtures = {"team":"Manchester United","updated":datetime.datetime.utcnow().isoformat()+"Z","matches":dedup}

          # write with fallbacks
          assets = pathlib.Path("assets"); assets.mkdir(exist_ok=True)

          # keep old good table if new is broken
          table_path = assets/"table.json"
          if len(new_table["standings"]) < 10 and table_path.exists():
            try:
              old = json.loads(table_path.read_text(encoding="utf-8"))
              if isinstance(old, dict) and len(old.get("standings", [])) >= 10:
                print("[WARN] Incomplete table; keeping previous.")
                new_table = old
            except Exception: pass

          (assets/"table.json").write_text(json.dumps(new_table, ensure_ascii=False, indent=2), encoding="utf-8")
          (assets/"badges.json").write_text(json.dumps(badges_json, ensure_ascii=False, indent=2), encoding="utf-8")

          fix_path = assets/"fixtures.json"
          if len(new_fixtures["matches"]) == 0 and fix_path.exists():
            try:
              oldf = json.loads(fix_path.read_text(encoding="utf-8"))
              if isinstance(oldf, dict) and len(oldf.get("matches", [])) > 0:
                print("[WARN] Empty fixtures; keeping previous.")
                new_fixtures = oldf
            except Exception: pass
          (assets/"fixtures.json").write_text(json.dumps(new_fixtures, ensure_ascii=False, indent=2), encoding="utf-8")
          (assets/"update_stamp.txt").write_text(datetime.datetime.utcnow().isoformat()+"Z", encoding="utf-8")
          print("Wrote assets/table.json, assets/fixtures.json, assets/badges.json")
          PY

      - name: Commit assets
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add assets/*
            git commit -m "chore: refresh assets ($(date -u +'%Y-%m-%dT%H:%M:%SZ'))"
            git push
          else
            echo "No changes."
          fi
