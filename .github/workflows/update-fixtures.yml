name: Update site data (TSDB season → table + MUFC fixtures)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "23 5 * * *"   # daily 05:23 UTC

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Build assets
        env:
          # Optional repo VAR to force a season string (e.g. "2025-2026")
          SEASON: ${{ vars.SEASON }}
        run: |
          python - <<'PY'
          import json, os, pathlib, time, urllib.request, datetime, sys
          from collections import defaultdict

          LEAGUE_ID = "4328"  # Premier League (TSDB)

          def get(url, tries=4, sleep=1.2):
            for i in range(tries):
              try:
                req = urllib.request.Request(url, headers={"User-Agent":"thekeelan-updater/2.0"})
                with urllib.request.urlopen(req, timeout=35) as r:
                  return json.loads(r.read().decode("utf-8"))
              except Exception as e:
                if i == tries-1:
                  print(f"[ERR] GET {url} -> {e}", file=sys.stderr)
                  raise
                time.sleep(sleep)

          # ---------- season autodetect (Aug→Jul), allow override ----------
          forced = (os.environ.get("SEASON") or "").strip()
          if forced:
            SEASON = forced
          else:
            today = datetime.date.today()
            SEASON = f"{today.year}-{today.year+1}" if today.month >= 8 else f"{today.year-1}-{today.year}"
          print(f"[INFO] Using season: {SEASON}")

          # ---------- fetch full league season events + team list ----------
          season_events = get(f"https://www.thesportsdb.com/api/v1/json/3/eventsseason.php?id={LEAGUE_ID}&s={SEASON}") or {}
          events = season_events.get("events") or []
          if not events:
            print("[WARN] TSDB returned 0 season events. Table may be empty.", file=sys.stderr)

          team_list = get(f"https://www.thesportsdb.com/api/v1/json/3/lookup_all_teams.php?id={LEAGUE_ID}") or {}
          teams = team_list.get("teams") or []
          team_badge = {}       # name → badge URL
          team_seen = set()
          for t in teams:
            nm = (t.get("strTeam") or "").strip()
            if nm:
              team_badge[nm] = t.get("strTeamBadge") or None
              team_seen.add(nm)

          # ensure we track all 20 clubs even if they have 0 completed matches yet
          standings_map = {
            nm: {"team": nm, "played":0,"won":0,"drawn":0,"lost":0,"gf":0,"ga":0,"gd":0,"pts":0,"badge":team_badge.get(nm)}
            for nm in team_seen
          }

          # tally from completed matches only
          def to_int(x):
            try: return int(x)
            except: return None

          for e in events:
            home = (e.get("strHomeTeam") or "").strip()
            away = (e.get("strAwayTeam") or "").strip()
            hs = to_int(e.get("intHomeScore"))
            as_ = to_int(e.get("intAwayScore"))
            if not home or not away: 
              continue
            # if teams not in the team list (rare), create rows on the fly
            for nm in (home, away):
              if nm not in standings_map:
                standings_map[nm] = {"team": nm, "played":0,"won":0,"drawn":0,"lost":0,"gf":0,"ga":0,"gd":0,"pts":0,"badge": team_badge.get(nm)}

            # only count finished matches (both scores present)
            if hs is None or as_ is None:
              continue

            H = standings_map[home]; A = standings_map[away]
            H["played"] += 1; A["played"] += 1
            H["gf"] += hs; H["ga"] += as_; H["gd"] = H["gf"] - H["ga"]
            A["gf"] += as_; A["ga"] += hs; A["gd"] = A["gf"] - A["ga"]

            if hs == as_:
              H["drawn"] += 1; A["drawn"] += 1
              H["pts"] += 1;  A["pts"] += 1
            elif hs > as_:
              H["won"] += 1; A["lost"] += 1
              H["pts"] += 3
            else:
              A["won"] += 1; H["lost"] += 1
              A["pts"] += 3

          # sort: points desc, GD desc, GF desc, team asc
          rows = list(standings_map.values())
          rows.sort(key=lambda r: (-r["pts"], -r["gd"], -r["gf"], r["team"]))
          for i, r in enumerate(rows, start=1):
            r["pos"] = i

          table = {
            "season": SEASON,
            "updated": datetime.datetime.utcnow().isoformat()+"Z",
            "standings": rows
          }

          # ---------- MUFC fixtures (from same season events — consistent + complete) ----------
          mu_names = {"manchester united","man utd","manchester u."}
          def norm_ts(strTimestamp, dateEvent, strTime):
            ts = (strTimestamp or "").strip()
            if not ts:
              d = (dateEvent or "").strip()
              t = (strTime or "00:00:00").strip()
              ts = f"{d}T{t}".strip() if d else t
            if ts and 'Z' not in ts and '+' not in ts:
              ts += 'Z'
            return ts

          mu_events = []
          for e in events:
            h = (e.get("strHomeTeam") or "").strip().lower()
            a = (e.get("strAwayTeam") or "").strip().lower()
            if h in mu_names or a in mu_names:
              # derive FINISHED vs SCHEDULED
              hs = to_int(e.get("intHomeScore"))
              as_ = to_int(e.get("intAwayScore"))
              finished = (hs is not None and as_ is not None)
              status = "FINISHED" if finished else "SCHEDULED"

              # outcome from MUFC perspective if finished
              score = None
              if finished:
                is_mu_home = h in mu_names
                mu_sc = hs if is_mu_home else as_
                op_sc = as_ if is_mu_home else hs
                outcome = "D" if mu_sc == op_sc else ("W" if mu_sc > op_sc else "L")
                score = {"home": hs, "away": as_, "outcome": outcome}

              mu_events.append({
                "date": norm_ts(e.get("strTimestamp"), e.get("dateEvent"), e.get("strTime")),
                "comp": e.get("strLeague") or (e.get("strLeagueShort") or ""),
                "home": e.get("strHomeTeam") or "",
                "away": e.get("strAwayTeam") or "",
                "status": status,
                "score": score
              })

          # de-dupe & sort by date
          seen, dedup = set(), []
          for m in mu_events:
            k = (m["date"], m["home"], m["away"])
            if k not in seen:
              seen.add(k)
              dedup.append(m)
          dedup.sort(key=lambda m: m["date"])

          fixtures = {
            "team": "Manchester United",
            "updated": datetime.datetime.utcnow().isoformat()+"Z",
            "matches": dedup
          }

          # ---------- write ----------
          assets = pathlib.Path("assets")
          assets.mkdir(exist_ok=True)
          (assets/"table.json").write_text(json.dumps(table, ensure_ascii=False, indent=2), encoding="utf-8")
          (assets/"fixtures.json").write_text(json.dumps(fixtures, ensure_ascii=False, indent=2), encoding="utf-8")
          (assets/"update_stamp.txt").write_text(datetime.datetime.utcnow().isoformat()+"Z", encoding="utf-8")
          print("Wrote assets/table.json and assets/fixtures.json")
          PY

      - name: Commit assets
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add assets/*
            git commit -m "chore: refresh assets ($(date -u +'%Y-%m-%dT%H:%M:%SZ'))"
            git push
          else
            echo "No changes."
          fi
