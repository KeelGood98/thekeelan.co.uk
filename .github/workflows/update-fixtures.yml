name: Update site data (TSDB table + MUFC fixtures)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "23 5 * * *"   # daily 05:23 UTC

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Build assets
        env:
          # Optional: override the season via repo VARS → SEASON: "2025-2026"
          SEASON: ${{ vars.SEASON }}
        run: |
          python - <<'PY'
          import json, os, pathlib, time, urllib.request, datetime, sys

          # ---------- helpers ----------
          def get(url, tries=4, sleep=1.2):
            for i in range(tries):
              try:
                req = urllib.request.Request(url, headers={"User-Agent":"thekeelan-updater/1.1"})
                with urllib.request.urlopen(req, timeout=30) as r:
                  return json.loads(r.read().decode("utf-8"))
              except Exception as e:
                if i == tries-1:
                  print(f"[ERR] GET {url} -> {e}", file=sys.stderr)
                  raise
                time.sleep(sleep)

          def norm_ts(strTimestamp, dateEvent, strTime):
            """
            Build a sane ISO-ish timestamp. DO NOT append 'Z' if timestamp already has
            a timezone (contains '+' or endswith 'Z').
            """
            ts = (strTimestamp or "").strip()
            if not ts:
              d = (dateEvent or "").strip()
              t = (strTime or "00:00:00").strip()
              ts = f"{d}T{t}".strip() if d else t
            # Only append Z if there's no timezone info already
            if ts and 'Z' not in ts and '+' not in ts:
              ts += 'Z'
            return ts

          # ---------- season ----------
          forced = (os.environ.get("SEASON") or "").strip()
          if forced:
            SEASON = forced
          else:
            today = datetime.date.today()
            SEASON = f"{today.year}-{today.year+1}" if today.month >= 8 else f"{today.year-1}-{today.year}"
          print(f"[INFO] Season: {SEASON}")

          # ---------- PL table ----------
          # TSDB PL league id: 4328
          table_api = f"https://www.thesportsdb.com/api/v1/json/3/lookuptable.php?l=4328&s={SEASON}"
          t = get(table_api) or {}
          rows = t.get("table") or []
          if not rows:
            print("[WARN] TSDB returned no table rows. Check the season string.")

          standings = [{
              "pos": int(r.get("intRank") or 0),
              "team": r.get("strTeam") or "",
              "played": int(r.get("intPlayed") or 0),
              "won": int(r.get("intWin") or 0),
              "drawn": int(r.get("intDraw") or 0),
              "lost": int(r.get("intLoss") or 0),
              "gf": int(r.get("intGoalsFor") or 0),
              "ga": int(r.get("intGoalsAgainst") or 0),
              "gd": int(r.get("intGoalDifference") or 0),
              "pts": int(r.get("intPoints") or 0),
              "badge": r.get("strTeamBadge") or None
          } for r in rows]
          standings.sort(key=lambda x: x["pos"] or 999)

          table = {
            "season": SEASON,
            "updated": datetime.datetime.utcnow().isoformat()+"Z",
            "standings": standings
          }

          # ---------- MUFC fixtures/results ----------
          # Resolve exact team id
          search = get("https://www.thesportsdb.com/api/v1/json/3/searchteams.php?t=Manchester%20United") or {}
          teams = search.get("teams") or []
          if not teams:
            print("[ERR] No MUFC team rows found.", file=sys.stderr); sys.exit(1)

          mu_names = {"manchester united", "man utd", "manchester u."}
          mu = None
          for tr in teams:
            if (tr.get("strTeam") or "").strip().lower() in mu_names:
              mu = tr; break
          mu = mu or teams[0]
          mu_id = mu["idTeam"]
          print(f"[INFO] MUFC team id: {mu_id}")

          # Use all three feeds for belt-and-braces (season + last + next), then filter to MUFC only.
          feeds = []
          feeds.append(get(f"https://www.thesportsdb.com/api/v1/json/3/eventsseason.php?id={mu_id}&s={SEASON}") or {})
          feeds.append(get(f"https://www.thesportsdb.com/api/v1/json/3/eventslast.php?id={mu_id}") or {})
          feeds.append(get(f"https://www.thesportsdb.com/api/v1/json/3/eventsnext.php?id={mu_id}") or {})

          raw_events = []
          for f in feeds:
            raw_events.extend(f.get("events") or [])
            raw_events.extend(f.get("results") or [])

          # Strict keep: only games where MUFC is home or away
          def keep_mu(e):
            h = (e.get("strHomeTeam") or "").strip().lower()
            a = (e.get("strAwayTeam") or "").strip().lower()
            return h in mu_names or a in mu_names

          kept = [e for e in raw_events if keep_mu(e)]

          # Map → our schema
          def map_event(e):
            ts = norm_ts(e.get("strTimestamp"), e.get("dateEvent"), e.get("strTime"))
            home = e.get("strHomeTeam") or ""
            away = e.get("strAwayTeam") or ""
            comp = e.get("strLeague") or (e.get("strLeagueShort") or "")

            hs, as_ = e.get("intHomeScore"), e.get("intAwayScore")
            finished = (hs is not None and as_ is not None)
            status = "FINISHED" if finished else "SCHEDULED"

            score = None
            if finished:
              try:
                hs, as_ = int(hs), int(as_)
              except Exception:
                hs = int(str(hs or "0").strip() or 0)
                as_ = int(str(as_ or "0").strip() or 0)
              is_mu_home = home.strip().lower() in mu_names
              mu_score = hs if is_mu_home else as_
              opp_score = as_ if is_mu_home else hs
              outcome = "D" if mu_score == opp_score else ("W" if mu_score > opp_score else "L")
              score = {"home": hs, "away": as_, "outcome": outcome}

            return {"date": ts, "comp": comp, "home": home, "away": away, "status": status, "score": score}

          mapped = [map_event(e) for e in kept]

          # De-duplicate using (date, home, away)
          seen, dedup = set(), []
          for m in mapped:
            k = (m["date"], m["home"], m["away"])
            if k not in seen:
              seen.add(k)
              dedup.append(m)

          # Sort ascending by date; frontend will split upcoming/recent
          dedup.sort(key=lambda m: m["date"])

          fixtures = {
            "team": "Manchester United",
            "updated": datetime.datetime.utcnow().isoformat()+"Z",
            "matches": dedup
          }

          # ---------- write ----------
          assets = pathlib.Path("assets")
          assets.mkdir(exist_ok=True)
          (assets/"table.json").write_text(json.dumps(table, ensure_ascii=False, indent=2), encoding="utf-8")
          (assets/"fixtures.json").write_text(json.dumps(fixtures, ensure_ascii=False, indent=2), encoding="utf-8")
          (assets/"update_stamp.txt").write_text(datetime.datetime.utcnow().isoformat()+"Z", encoding="utf-8")
          print("Wrote assets/table.json and assets/fixtures.json")
          PY

      - name: Commit assets
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add assets/*
            git commit -m "chore: refresh assets ($(date -u +'%Y-%m-%dT%H:%M:%SZ'))"
            git push
          else
            echo "No changes."
          fi
