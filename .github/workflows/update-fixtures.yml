name: Update site data (TSDB table + MUFC fixtures)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "23 5 * * *"   # daily 05:23 UTC

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Build assets
        env:
          # Optional: repo variable to force a specific season (e.g. 2026-2027)
          SEASON: ${{ vars.SEASON }}
        run: |
          python - <<'PY'
          import json, os, pathlib, time, urllib.request, datetime, sys, itertools

          # ----------------- helpers -----------------
          def get(url, tries=4, sleep=1.2):
            for i in range(tries):
              try:
                req = urllib.request.Request(url, headers={"User-Agent":"thekeelan-updater/1.0"})
                with urllib.request.urlopen(req, timeout=25) as r:
                  return json.loads(r.read().decode("utf-8"))
              except Exception as e:
                if i == tries-1:
                  print(f"[ERR] GET {url} -> {e}", file=sys.stderr)
                  raise
                time.sleep(sleep)

          def iso_timestamp(e):
            ts = (e.get("strTimestamp") or "").strip()
            if not ts:
              de = (e.get("dateEvent") or "").strip()
              tm = (e.get("strTime") or "00:00:00").strip()
              ts = (de + "T" + tm).strip() if de else tm
            if ts and not ts.endswith("Z"):
              ts += "Z"
            return ts

          # ----------------- season -----------------
          forced = (os.environ.get("SEASON") or "").strip()
          if forced:
            SEASON = forced
          else:
            today = datetime.date.today()
            SEASON = f"{today.year}-{today.year+1}" if today.month >= 8 else f"{today.year-1}-{today.year}"
          print(f"[INFO] Using season: {SEASON}")

          # ----------------- PL table (TSDB) -----------------
          # TSDB PL league id: 4328
          table_api = f"https://www.thesportsdb.com/api/v1/json/3/lookuptable.php?l=4328&s={SEASON}"
          t = get(table_api) or {}
          rows = t.get("table") or []

          standings = []
          for r in rows:
            standings.append({
              "pos": int(r.get("intRank") or 0),
              "team": r.get("strTeam") or "",
              "played": int(r.get("intPlayed") or 0),
              "won": int(r.get("intWin") or 0),
              "drawn": int(r.get("intDraw") or 0),
              "lost": int(r.get("intLoss") or 0),
              "gf": int(r.get("intGoalsFor") or 0),
              "ga": int(r.get("intGoalsAgainst") or 0),
              "gd": int(r.get("intGoalDifference") or 0),
              "pts": int(r.get("intPoints") or 0),
              "badge": r.get("strTeamBadge") or None
            })
          standings.sort(key=lambda x: x["pos"] or 999)

          table = {
            "season": SEASON,
            "updated": datetime.datetime.utcnow().isoformat()+"Z",
            "standings": standings
          }

          # ----------------- MUFC fixtures/results (TSDB) -----------------
          # 1) Resolve exact team row
          team_search = get("https://www.thesportsdb.com/api/v1/json/3/searchteams.php?t=Manchester%20United") or {}
          teams = team_search.get("teams") or []
          if not teams:
            print("[ERR] No teams returned for Manchester United.", file=sys.stderr)
            sys.exit(1)

          mu_names = {"manchester united", "man utd", "manchester u."}
          mu_row = None
          for trow in teams:
            name = (trow.get("strTeam") or "").strip().lower()
            if name in mu_names:
              mu_row = trow
              break
          if not mu_row:
            mu_row = teams[0]

          team_id = mu_row["idTeam"]
          team_canonical = mu_row.get("strTeam") or "Manchester United"
          print(f"[INFO] Using TSDB team id {team_id} for {team_canonical}")

          # 2) Fetch last + next
          last = get(f"https://www.thesportsdb.com/api/v1/json/3/eventslast.php?id={team_id}") or {}
          nxt  = get(f"https://www.thesportsdb.com/api/v1/json/3/eventsnext.php?id={team_id}") or {}

          # 3) Strict filter: keep only events where MUFC is home or away
          def only_mu(items):
            out = []
            for e in items or []:
              h = (e.get("strHomeTeam") or "").strip().lower()
              a = (e.get("strAwayTeam") or "").strip().lower()
              if h in mu_names or a in mu_names:
                out.append(e)
            return out

          last_clean = only_mu(last.get("results"))
          next_clean = only_mu(nxt.get("events"))

          # 4) Map to our schema
          def map_event(e):
            ts = iso_timestamp(e)
            home = e.get("strHomeTeam") or ""
            away = e.get("strAwayTeam") or ""
            comp = e.get("strLeague") or (e.get("strLeagueShort") or "")

            hs, as_ = e.get("intHomeScore"), e.get("intAwayScore")
            finished = (hs is not None and as_ is not None)
            status = "FINISHED" if finished else "SCHEDULED"

            score = None
            if finished:
              hs, as_ = int(hs), int(as_)
              is_mu_home = home.strip().lower() in mu_names
              mu = hs if is_mu_home else as_
              opp = as_ if is_mu_home else hs
              outcome = "D" if mu == opp else ("W" if mu > opp else "L")
              score = {"home": hs, "away": as_, "outcome": outcome}

            return {
              "date": ts,
              "comp": comp,
              "home": home,
              "away": away,
              "status": status,
              "score": score
            }

          mapped = [map_event(e) for e in (last_clean or [])] + [map_event(e) for e in (next_clean or [])]

          # 5) De-duplicate by date+teams and sort descending by date for finished, ascending for upcoming
          def key(m): return (m["date"], m["home"], m["away"])
          seen = set()
          dedup = []
          for m in mapped:
            k = key(m)
            if k not in seen:
              seen.add(k)
              dedup.append(m)

          # Sort all by date then split if you want; the front-end handles slicing & grouping
          dedup.sort(key=lambda m: m["date"])

          fixtures = {
            "team": "Manchester United",
            "updated": datetime.datetime.utcnow().isoformat()+"Z",
            "matches": dedup
          }

          # ----------------- write -----------------
          assets = pathlib.Path("assets")  # ensure single-level /assets in repo root
          assets.mkdir(exist_ok=True)
          (assets/"table.json").write_text(json.dumps(table, ensure_ascii=False, indent=2), encoding="utf-8")
          (assets/"fixtures.json").write_text(json.dumps(fixtures, ensure_ascii=False, indent=2), encoding="utf-8")
          (assets/"update_stamp.txt").write_text(datetime.datetime.utcnow().isoformat()+"Z", encoding="utf-8")
          print("Wrote assets/table.json and assets/fixtures.json")
          PY

      - name: Commit assets
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add assets/*
            git commit -m "chore: refresh assets ($(date -u +'%Y-%m-%dT%H:%M:%SZ'))"
            git push
          else
            echo "No changes."
          fi
