name: Update site data (TSDB season → table + MUFC fixtures)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "23 5 * * *"   # daily 05:23 UTC

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Build assets
        env:
          # Optional: set a repo VAR named SEASON (e.g. 2025-2026) to force a season
          SEASON: ${{ vars.SEASON }}
        run: |
          python - <<'PY'
          import json, os, pathlib, time, urllib.request, datetime, sys

          LEAGUE_ID = "4328"  # Premier League

          def get(url, tries=4, sleep=1.2):
            for i in range(tries):
              try:
                req = urllib.request.Request(url, headers={"User-Agent":"thekeelan-updater/2.4"})
                with urllib.request.urlopen(req, timeout=35) as r:
                  return json.loads(r.read().decode("utf-8"))
              except Exception as e:
                if i == tries-1:
                  print(f"[ERR] GET {url} -> {e}", file=sys.stderr)
                  raise
                time.sleep(sleep)

          def to_int(x):
            try: return int(x)
            except: return None

          def norm_ts(strTimestamp, dateEvent, strTime):
            ts = (strTimestamp or "").strip()
            if not ts:
              d = (dateEvent or "").strip()
              t = (strTime or "00:00:00").strip()
              ts = f"{d}T{t}".strip() if d else t
            if ts and 'Z' not in ts and '+' not in ts:
              ts += 'Z'
            return ts

          # ---------- season autodetect (Aug→Jul), allow override ----------
          forced = (os.environ.get("SEASON") or "").strip()
          if forced:
            SEASON = forced
          else:
            today = datetime.date.today()
            SEASON = f"{today.year}-{today.year+1}" if today.month >= 8 else f"{today.year-1}-{today.year}"
          print(f"[INFO] Using season: {SEASON}")

          # ---------- full season events ----------
          season_events = get(f"https://www.thesportsdb.com/api/v1/json/3/eventsseason.php?id={LEAGUE_ID}&s={SEASON}") or {}
          events = season_events.get("events") or []

          # Derive participants from events (most reliable when present)
          event_teams = []
          for e in events:
            h = (e.get("strHomeTeam") or "").strip()
            a = (e.get("strAwayTeam") or "").strip()
            if h: event_teams.append(h)
            if a: event_teams.append(a)

          # Try table endpoint as a hint (sometimes flaky/short)
          table_rows = (get(f"https://www.thesportsdb.com/api/v1/json/3/lookuptable.php?l={LEAGUE_ID}&s={SEASON}") or {}).get("table") or []
          table_teams = [(r.get("strTeam") or "").strip() for r in table_rows if (r.get("strTeam") or "").strip()]

          # Try league-wide team list (may include historic teams)
          search_rows = (get("https://www.thesportsdb.com/api/v1/json/3/search_all_teams.php?l=English%20Premier%20League") or {}).get("teams") or []
          league_teams = [(t.get("strTeam") or "").strip() for t in search_rows if (t.get("strTeam") or "").strip()]

          # Assemble participants: prefer teams actually present in season events,
          # then top up from table (if any), then league-wide list — until we reach 20.
          participants, seen = [], set()
          def add_many(lst):
            for nm in lst:
              if nm and nm not in seen:
                participants.append(nm); seen.add(nm)
                if len(participants) >= 20: return
          add_many(sorted(set(event_teams)))
          if len(participants) < 20: add_many(table_teams)
          if len(participants) < 20: add_many(league_teams)
          participants = participants[:20]

          # Badges (best effort)
          try:
            team_list = get(f"https://www.thesportsdb.com/api/v1/json/3/lookup_all_teams.php?id={LEAGUE_ID}") or {}
            all_badges = { (t.get("strTeam") or "").strip(): t.get("strTeamBadge") or None
                           for t in (team_list.get("teams") or []) }
          except Exception:
            all_badges = {}
          badges = {nm: all_badges.get(nm) for nm in participants}

          # Build standings from finished matches where both teams are in participants
          standings_map = {
            nm: {"team": nm, "played":0,"won":0,"drawn":0,"lost":0,"gf":0,"ga":0,"gd":0,"pts":0,"badge": badges.get(nm)}
            for nm in participants
          }
          for e in events:
            home = (e.get("strHomeTeam") or "").strip()
            away = (e.get("strAwayTeam") or "").strip()
            if home not in standings_map or away not in standings_map:
              continue
            hs = to_int(e.get("intHomeScore")); as_ = to_int(e.get("intAwayScore"))
            if hs is None or as_ is None:  # count finished only
              continue
            H = standings_map[home]; A = standings_map[away]
            H["played"] += 1; A["played"] += 1
            H["gf"] += hs; H["ga"] += as_; H["gd"] = H["gf"] - H["ga"]
            A["gf"] += as_; A["ga"] += hs; A["gd"] = A["gf"] - A["ga"]
            if hs == as_:
              H["drawn"] += 1; A["drawn"] += 1; H["pts"] += 1; A["pts"] += 1
            elif hs > as_:
              H["won"] += 1; A["lost"] += 1; H["pts"] += 3
            else:
              A["won"] += 1; H["lost"] += 1; A["pts"] += 3

          rows = list(standings_map.values())
          rows.sort(key=lambda r: (-r["pts"], -r["gd"], -r["gf"], r["team"]))
          for i, r in enumerate(rows, start=1):
            r["pos"] = i

          new_table = {
            "season": SEASON,
            "updated": datetime.datetime.utcnow().isoformat()+"Z",
            "standings": rows
          }

          # ---------- MUFC fixtures (season + last + next; strict filter) ----------
          mu_names = {"manchester united","man utd","manchester u."}
          search = get("https://www.thesportsdb.com/api/v1/json/3/searchteams.php?t=Manchester%20United") or {}
          teams = search.get("teams") or []
          if not teams:
            print("[ERR] No MUFC team rows found.", file=sys.stderr); sys.exit(1)
          mu = None
          for tr in teams:
            if (tr.get("strTeam") or "").strip().lower() in mu_names:
              mu = tr; break
          mu = mu or teams[0]
          mu_id = mu["idTeam"]

          last = get(f"https://www.thesportsdb.com/api/v1/json/3/eventslast.php?id={mu_id}") or {}
          nxt  = get(f"https://www.thesportsdb.com/api/v1/json/3/eventsnext.php?id={mu_id}") or {}

          raw = []
          raw.extend(events)                         # whole PL season
          raw.extend(last.get("results") or [])      # MUFC last
          raw.extend(nxt.get("events") or [])        # MUFC next

          def is_mu(e):
            h = (e.get("strHomeTeam") or "").strip().lower()
            a = (e.get("strAwayTeam") or "").strip().lower()
            return h in mu_names or a in mu_names

          def map_event(e):
            ts = norm_ts(e.get("strTimestamp"), e.get("dateEvent"), e.get("strTime"))
            home = e.get("strHomeTeam") or ""
            away = e.get("strAwayTeam") or ""
            comp = e.get("strLeague") or (e.get("strLeagueShort") or "")
            tv   = (e.get("strTVStation") or "").strip() or None
            hs, as_ = to_int(e.get("intHomeScore")), to_int(e.get("intAwayScore"))
            finished = (hs is not None and as_ is not None)
            status = "FINISHED" if finished else "SCHEDULED"
            score = None
            if finished:
              is_mu_home = (home.strip().lower() in mu_names)
              mu_sc, op_sc = (hs, as_) if is_mu_home else (as_, hs)
              outcome = "D" if mu_sc == op_sc else ("W" if mu_sc > op_sc else "L")
              score = {"home": hs, "away": as_, "outcome": outcome}
            return {"date": ts, "comp": comp, "home": home, "away": away, "status": status, "score": score, "tv": tv}

          mapped = [map_event(e) for e in raw if is_mu(e)]
          seen2, dedup = set(), []
          for m in mapped:
            k = (m["date"], m["home"], m["away"])
            if k not in seen2:
              seen2.add(k)
              dedup.append(m)
          dedup.sort(key=lambda m: m["date"])

          new_fixtures = {
            "team": "Manchester United",
            "updated": datetime.datetime.utcnow().isoformat()+"Z",
            "matches": dedup
          }

          # ---------- write with SAFE fallback ----------
          assets = pathlib.Path("assets"); assets.mkdir(exist_ok=True)

          # Fallback: keep prior table if new one looks broken (e.g., <10 teams)
          table_path = assets/"table.json"
          if len(new_table["standings"]) < 10 and table_path.exists():
            try:
              old = json.loads(table_path.read_text(encoding="utf-8"))
              if isinstance(old, dict) and len(old.get("standings", [])) >= 10:
                print("[WARN] New table incomplete; keeping previous table.json")
                new_table = old
            except Exception as e:
              print("[WARN] Unable to read previous table.json:", e)

          (assets/"table.json").write_text(json.dumps(new_table, ensure_ascii=False, indent=2), encoding="utf-8")

          # Fixtures: if nothing, keep old file
          fix_path = assets/"fixtures.json"
          if len(new_fixtures["matches"]) == 0 and fix_path.exists():
            try:
              oldf = json.loads(fix_path.read_text(encoding="utf-8"))
              if isinstance(oldf, dict) and len(oldf.get("matches", [])) > 0:
                print("[WARN] New fixtures empty; keeping previous fixtures.json")
                new_fixtures = oldf
            except Exception as e:
              print("[WARN] Unable to read previous fixtures.json:", e)

          (assets/"fixtures.json").write_text(json.dumps(new_fixtures, ensure_ascii=False, indent=2), encoding="utf-8")
          (assets/"update_stamp.txt").write_text(datetime.datetime.utcnow().isoformat()+"Z", encoding="utf-8")
          print("Wrote assets/table.json and assets/fixtures.json")
          PY

      - name: Commit assets
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add assets/*
            git commit -m "chore: refresh assets ($(date -u +'%Y-%m-%dT%H:%M:%SZ'))"
            git push
          else
            echo "No changes."
          fi
